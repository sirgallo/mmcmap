# PCMap 

### A Concurrent, Versioned Hash Array Mapped Trie
### With modified form of Path Copying that implements Versioning and Copy-On-Write


## Issue

One issue when working with memory mapped files is ensuring data integrity on concurrent operations, especially when trying to implement an immutable datastructure like a concurrent hash array mapped trie (`chamt`). Many approaches to memory mapped data structures is to enforce a single writer that updates the data in the data structure, which can become a bottleneck. The persistent concurrent hash array mapped trie looks to circumvent this issue with a couple of additional mechanisms described in the following.

## Proposal

The `pcmap` would extend the current `chamt` path copying technique with a form of versioning to ensure data integrity and allow multiple write operations to succeed, using retries. This is inspired by the `atomic compare-and-swap` operations used in the `chamt`, where many concurrent operations can attempt to update pointers to new nodes but if a concurrent operation is already modifying the same location, the operation is discarded and retried back at the root of the data structure. The memory mapped file for the `pcmap` will be treated as an append only data structure, where data can only be appended to the buffer but cannot be modified or removed, essentially making the memory mapped file a view of all operations that have ever occured on the data structure. Instead of performing an atomic compare and swap operation on the original node, essentially replacing the original with the copy, the operation will create a copy of each node in the path with a new version of the node starting at the root, all the way down the structure until the updated value. This is essentially taking the path copying concept from the in-memory `chamt` and updates it to a form of `Copy-on-Write`. Every node will contain both the offset from the beginning of the memory mapped file, determined by `(pageId * pageSize) + offset from page start`, as well as the current version of the node, increasing from `1`.

At the start of the memory mapped file, page 0 will be allocated by default to hold metadata regarding the current version of the `pcmap`, as well as the current pageId and offset for the location of the root of the trie. When a path copy is created, the entire copy from the new node up to the root, with new version numbers, will be returned to the start of the operation. This path is not an entire copy of the trie, but just a copy of the path down to the new node, and new versions of nodes can point to nodes of different versions in the memory mapped file if they were not in the path. The version only truly matters for the root node and metadata, since the root node is the entry point into the data structure for all operations. The copy then will perform a check against the metadata page. If its version number is higher than the version number currently in the metadata page, it is assumed that the operation can be safely applied to the memory mapped file since no other threads modified the structure at the same time. Atomic updates will be applied on the version, as well as on the pageId and offset pointing to the location of the new root for the trie. The copy will then be appended to the end of the memory mappped file and all operations will then start traversing the trie at the new root location. If the operation finds that after performing path copying the metadata page holds a value equal to its own or higher, the copy is discarded, garbage collection cleans up the copied nodes, and the operation is retried from the new root node of the data structure.